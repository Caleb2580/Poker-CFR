# Poker CFR (Counterfactual Regret Minimization)
## This program uses counterfactual regret minimization to solve the nash equilibrium (Most Optimal Strategy) for the flop for heads up (1v1) poker. It also contains the logic for poker, and calculating poker odds. This is implemented in the following files: oth.py, per_calc.py, poker_calc.py. The poker_cfr_flop_2.py file contains the logic for the CFR.

# Counterfactual Regret Minimization
### CFR is a very effective way of calculating the risk and reward for decisions in games where we don't have all of the information. It learns by determining the reward for decisions, and adjusting it's strategy accordingly. An easy game we can apply this to is Rock, Paper, Scissors (RPS). Obviously the nash equilibrium is picking at random because if you follow any sort of pattern, your opponent can take advantage of it. So to calculate the regret for a decision in RPS, we can use the example of Rock vs. Paper. The person who chose rock would recieve regret for that decision, and therefore be more likely to not choice that in the future. They will also be more inclined to choose scissors because that would've made them win. And paper would be unaffected. If you keep doing this, you will eventually come to the conclusion that choosing at random is the best strategy. It is a lot more complicated in poker, but it is the same idea.

# Modifications for Efficiency
### I know I have heard it somewhere, but supposedly, poker has more possibilities than atoms in the universe. Which means that without some sort of quantum computing, this would take lifetimes to solve. Since I didn't want to wait lifetimes, I came up with a different solution. This one does lose out on some accuracy, but it is a trade-off I am more than willing to take. Instead of performing this for every possible combination of cards, my plan was to come up with an amount of hands that would win in a scenario, and then classify it into a percentile(Bottom 20%, Top 20%, etc.). This way I would account for trillions of possibilities without having to test each individual one. My plan was to just run a loop and test out every possible hand, but when there are 5 cards to come out, and multiple players, it would still take a ton of time. To solve this problem, I decided to copy how my human brain thinks, and come up with the hands that beat me, and then calculate the odds of those cards coming out on the table. That way, I would only have to account for the cards coming out on the table, and not for all cards. I also planned on using a chart for pre-flop to save a lot of time. This saved a ton of time, and made this possible.

# **RESULTS!!!**
## Hopefully my explanation has made you as excited about this as I am. After training on 50,000 games of poker, it has learned a lot. I have a couple images, one from the 50th epoch, and one from the 5000th epoch. This way we can really see what it's learned. First, I am going to explain how to read the data.
![data](0_4021.png)
#### Some of the lines are wrapping, but each new line starts with a tuple. Each line is formatted like this - (Win classification(higher is better), Tie classification) | Number of players | History ` [Strategy] ` [Regret sum]
#### The strategy and regret sum's length depends on the number of actions. For the history, each move is seperated by a comma, and each move consists of 2 characters, the first being the index of the player, and the second being the move. x means check, f means fold, A means all in, and the numbers are multiples of big blinds to raise. This sequence - 1x,01,11 - means that the second player(because of index) checks, the first player raises 1 BB, and the second player raises them another BB.
# 50th Epoch
## That picture is the 50th epoch. I will discuss the first line. First of all, we can see that it's winning classification is 4(out of 5). So far, with a 4/5 hand, it is leaning towards raising 4BB, but is also considering raising 5BB. Not awful for only 50 epochs. However, on the second line, we can see that it is going to make a huge mistake. With a winning classification of 2, it wants to go all in when someone raises it 1BB. This is obviously a bad decision. If we look a little bit lower, we can see why it wants to do that. It thinks that in every scenario below it, going all in is the best decision.
![5k](100_4021.png)
# 5000th Epoch
## After hours of learning, it has changed it's strategies. If we look at the first line again, it now wants to go with a lower bet, but isn't opposed to a higher bet. We can also see that on the second line, the player with the winning classification of 2 is going to fold 57% of the time, and never raise. This is much better than going all in. We can also see below, if it goes any further, 4 is prepared to go all in, and 2 is prepared to fold. This is a lot better.

## Although this example is pretty surface level, while testing the bot against some friends, I noticed some pretty cool things. First of all, it was very good at applying pressure, and knowing when to fold. And second of all, it was very good at bluffing.

